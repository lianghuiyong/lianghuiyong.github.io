[{"title":"MVP+Dagger使用笔记","date":"2017-04-18T10:37:36.000Z","path":"2017/04/18/MVP-Dagger使用笔记/","text":"前言 MVP： V层处理UI视图操作；P层实现业务逻辑操作（有设计需要的时候，核心业务甚至可以写到一个核心的P里面去）；M层为数据仓库，后台管理数据来源与数据控制，数据是来自网络、数据库、SP、缓存，示例：你可能会需要这样一个实现，一个数据列表，不需要实时性，但是需要给网络情况有问题时的用户提升用户体验，需要使用网络数据+本地缓存数据机制，那么，都可以统一在这个数据仓库做处理，代码逻辑层次很清晰，你应该会喜欢上这个设计。 V-P之间的调用方式采取依赖倒置原则，俗话就是使用抽象接口（回调）；P与V，代码写多了，其实会发现，V可以正常的调用P，P则要尽量少调用V，或者使用DataBinding，数据的变化使用绑定方式；P与M，M只与P做沟通，数据一般来自后台延时操作，这块也就是使用RxJava情况较多的地方，网络请求可以尝试使用ReTrofit。一般情况下，一个V对应一个P，而P和M，会出现一个P对应多个M的情况（M的接口多了，或许会把M按模块创建）。 Dagger+MVP： 则是实现在MVP 结构代码中，P、M 的对象创建使用 Dagger 注入方式。 我的基类库，欢迎Starcompile ‘com.better.android:appbase:x.y.z’ MVP使用V12345678910111213141516171819202122232425262728public class ExampleV extends BaseAppCompatActivity(or BaseFragment) implements ExampleContract.View&#123; @Inject ExamplePresenter presenter; @Override protected int getLayoutId() &#123; return R.layout.Example; &#125; @Override protected MvpPresenter getPresenter() &#123; return presenter; &#125; @Override public void init() &#123; super.init(); //使用Dagger创建presenter,并不需要new对象。 DaggerViewComponent.builder() .repositoryComponent(DaggerRepositoryComponent.builder().build()) .presenterModule(new PresenterModule(this)) .build() .inject(this); &#125; ......&#125; P1234567891011121314151617181920public class ExamplePresenter extends BasePresenter implements ExampleContract.Presenter &#123; @Inject Test1Repository repository1; @Inject Test2Repository repository2; @NonNull private ExampleContract.View view; //你的数据管理仓库 @NonNull private ExampleRepository repository; //参数使用MvpView类型，便于view的清单管理和PresenterModule的单一 public ExamplePresenter(MvpView view) &#123; this.mView = (ExampleContract.View)mView; &#125;&#125; Contract12345678910111213141516public interface ExampleContract &#123; /** * view接口层 处理界面 */ interface View extends MvpView&#123; ...... &#125; /** * Presenter接口层 处理业务 */ interface Presenter extends MvpPresenter&#123; List&lt;String&gt; getListData(); ...... &#125;&#125; M1234567891011121314151617181920/** * 数据管理仓库，控制选择使用remote数据还是local数据（SP、数据库、缓存） */public class Test1Repository implements Test1Api &#123; private final Test1Api mTest1RemoteDataSource; private final Test1Api mTest1LocalDataSource; @Inject public Test1Repository(@Local Test1LocalDataSource mTest1LocalDataSource, @Remote Test1RemoteDataSource mTest1RemoteDataSource) &#123; this.mTest1RemoteDataSource = mTest1RemoteDataSource; this.mTest1LocalDataSource = mTest1LocalDataSource; &#125; @Override public List&lt;String&gt; testGet() &#123; return mTest1LocalDataSource.testGet(); &#125;&#125; 123456public interface Test1Api &#123; /** * 测试接口 */ List&lt;String&gt; testGet();&#125; 1234567public class Test1RemoteDataSource implements Test1Api &#123; @Override public List&lt;String&gt; testGet() &#123; return null; &#125;&#125; 123456789101112131415161718192021/** * * 数据local实现方式 */public class Test1LocalDataSource implements Test1Api &#123; @Override public List&lt;String&gt; testGet() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"数据源一：1\"); list.add(\"数据源一：2\"); list.add(\"数据源一：3\"); list.add(\"数据源一：4\"); list.add(\"数据源一：5\"); list.add(\"数据源一：6\"); list.add(\"数据源一：7\"); list.add(\"数据源一：8\"); return list; &#125;&#125; Dagger使用简单说明： 一般创建对象方式，new一个Presenter对象，找到该对象的构造方法，传递参数，presenter指向该对象空间：1Presenter presenter = new Presenter(testActivity); Dagger则是把对象的构建方法、构造参数和具体的new动作，做了拆分到不同文件来处理 Dagger使用方式一：构造参数为当前this时 1、构造方法使用@Inject标注构造方法，表明该构造方法是Dagger注入入口1234@Injectpublic Presenter(MvpView mView) &#123; this.mView = (Test_DaggerListContract.View)mView;&#125; 2、使用@Module标注，创建构造方法使用时参数的Module，@Provides标注为该方法返回参数实体类型123456789101112131415@Modulepublic class PresenterModule &#123; private final MvpView mView; public PresenterModule(MvpView view) &#123; mView = view; &#125; @Provides @ActivityScoped MvpView provideTasksContractView() &#123; return mView; &#125;&#125; 3、创建ViewComponent，@Component标注的方法，ViewComponent会自动生成一个DaggerViewComponent的方法，modules后面为参数的Module，dependencies后面为注入的依赖。12345@ActivityScoped@Component(modules = PresenterModule.class)public interface ViewComponent &#123; void inject(Test_DaggerListActivity activity);&#125; 4、通过DaggerViewComponent的方法注入，@Inject标注的presenter对象已经实例化了。12345678910111213public class Test_DaggerListActivity &#123; @Inject Test_DaggerListPresenter presenter; @Override public void init() &#123; DaggerViewComponent.builder() //(new PresenterModule(this))时，通过this参数也已经把view对象传递给了module里的view了 .presenterModule(new PresenterModule(this)) .build() .inject(this); &#125;&#125; Dagger使用方式二：构造参数非当前this 1、构造方法使用@Inject标注构造方法，表明该构造方法是Dagger注入入口1234567891011121314public class Test2Repository implements Test2Api &#123; private final Test2Api mTest2RemoteDataSource; private final Test2Api mTest2LocalDataSource; @Inject public Test2Repository(@Local Test2LocalDataSource mTestLocalDataSource, @Remote Test2RemoteDataSource mTestRemoteDataSource) &#123; this.mTest2RemoteDataSource = mTestRemoteDataSource; this.mTest2LocalDataSource = mTestLocalDataSource; &#125; ......&#125; 2、使用@Module标注，创建构造方法使用时参数的Module，@Provides标注为该方法返回参数实体类型123456789101112131415161718@Modulepublic class Test1RepositoryModule &#123; @Singleton @Provides @Local Test1LocalDataSource provideTest1LocalDataSource() &#123; return new Test1LocalDataSource(); &#125; @Singleton @Provides @Remote Test1RemoteDataSource provideTest1RemoteDataSource() &#123; return new Test1RemoteDataSource(); &#125;&#125; 3、创建ViewComponent，@Component标注的方法，ViewComponent会自动生成一个DaggerViewComponent的方法，modules后面为参数的Module，dependencies后面为注入的依赖。123456@Singleton@Component(modules = &#123;Test1RepositoryModule.class&#125;)public interface RepositoryComponent &#123; Test1Repository getTest1Repository();&#125; 4、通过DaggerRepositoryComponent的方法注入，@Inject标注的repository1、repository2对象已经实例化了。1234567891011121314public class Test_DaggerListPresenter&#123; @Inject Test1Repository repository1; @Inject Test2Repository repository2; public Test_DaggerListPresenter() &#123; DaggerRepositoryComponent.builder().build(); &#125; ......&#125; 示例代码 MVP+Dagger实现一个数据源数据返回 MVP+Dagger使用基类列表页面实现两个数据源数据返回 参考文章 Dagger文章推荐1：使用Dagger2前你必须了解的一些设计原则 Dagger文章推荐2：使用Dagger 2进行依赖注入 Dagger文章推荐3：Google官方MVP+Dagger2架构详解 附 lambda配置 致谢","tags":[{"name":"Android","slug":"Android","permalink":"http://lianghuiyong.online/tags/Android/"}]},{"title":"MVP使用笔记","date":"2017-04-18T10:24:48.000Z","path":"2017/04/18/MVP使用笔记/","text":"前言 MVP： V层处理UI视图操作；P层实现业务逻辑操作（有设计需要的时候，核心业务甚至可以写到一个核心的P里面去）；M层为数据仓库，后台管理数据来源与数据控制，数据是来自网络、数据库、SP、缓存，示例：你可能会需要这样一个实现，一个数据列表，不需要实时性，但是需要给网络情况有问题时的用户提升用户体验，需要使用网络数据+本地缓存数据机制，那么，都可以统一在这个数据仓库做处理，代码逻辑层次很清晰，你应该会喜欢上这个设计。 V-P之间的调用方式采取依赖倒置原则，俗话就是使用抽象接口（回调）；P与V，代码写多了，其实会发现，V可以正常的调用P，P则要尽量少调用V，或者使用DataBinding，数据的变化使用绑定方式；P与M，M只与P做沟通，数据一般来自后台延时操作，这块也就是使用RxJava情况较多的地方，网络请求可以尝试使用ReTrofit。一般情况下，一个V对应一个P，而P和M，会出现一个P对应多个M的情况（M的接口多了，或许会把M按模块创建）。 我的基类库，欢迎Starcompile ‘com.better.android:appbase:x.y.z’ MVP使用介绍V12345678910111213public class ExampleV extends BaseAppCompatActivity(or BaseFragment) implements ExampleContract.View&#123; @Override protected int getLayoutId() &#123; return R.layout.Example; &#125; @Override protected MvpPresenter getPresenter() &#123; return null; &#125; ......&#125; P1234567891011121314public class ExamplePresenter extends BasePresenter implements ExampleContract.Presenter &#123; @NonNull private ExampleContract.View view; //你的数据管理仓库 @NonNull private ExampleRepository repository; public ExamplePresenter(@NonNull ExampleContract.View view) &#123; this.view = checkNotNull(view, \"view cannot be null!\"); this.repository = ExampleRepository.getInstance(RemoteExampleDataSource.getInstance(), LocalExampleDataSource.getInstance()); &#125;&#125; Contract123456789101112131415public interface ExampleContract &#123; /** * view接口层 处理界面 */ interface View extends MvpView&#123; ...... &#125; /** * Presenter接口层 处理业务 */ interface Presenter extends MvpPresenter&#123; ...... &#125;&#125; M123456789101112131415161718192021222324252627282930313233/** * 数据管理仓库，控制选择使用remote数据还是local数据（SP、数据库、缓存） */public class ExampleRepository implements ExampleApi &#123; @Nullable private static ExampleRepository INSTANCE = null; @NonNull private final ExampleApi localDataSource; @NonNull private final ExampleApi remoteDataSource; public ExampleRepository(@NonNull ExampleApi localDataSource, @NonNull ExampleApi remoteDataSource) &#123; this.localDataSource = checkNotNull(localDataSource); this.remoteDataSource = checkNotNull(remoteDataSource); &#125; public static ExampleRepository getINSTANCE(@NonNull ExampleApi localDataSource, @NonNull ExampleApi remoteDataSource) &#123; if (INSTANCE == null) &#123; INSTANCE = new ExampleRepository(localDataSource, remoteDataSource); &#125; return INSTANCE; &#125; @Override public Observable&lt;BaseResponseData&lt;String&gt;&gt; register(@Body ExampleRegisterBean sendBean) &#123; return remoteDataSource.register(sendBean); &#125; @Override public Observable&lt;BaseResponseData&lt;String&gt;&gt; unregister(@Body ExampleUnRegisterBean sendBean) &#123; return localDataSource.unregister(sendBean); &#125;&#125; 123456789101112131415public interface ExampleApi &#123; /** * 注册 * 使用retrofit请求 */ @POST(\"services/device/register\") Observable&lt;BaseResponseData&lt;String&gt;&gt; register(@Body RegisterBean sendBean); /** * 注销 * 使用非retrofit请求 */ Observable&lt;BaseResponseData&lt;String&gt;&gt; unregister(UnRegisterBean sendBean);&#125; 123456789101112131415161718192021222324252627282930313233343536//remote数据实现public class RemoteExampleDataSource implements ExampleApi &#123; private static RemoteExampleDataSource INSTANCE; public static RemoteExampleDataSource getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new RemoteExampleDataSource(); &#125; return INSTANCE; &#125; @Override public Observable&lt;BaseResponseData&lt;String&gt;&gt; register(@Body RegisterBean sendBean) &#123; /** * public static ExampleApi getExampleApi() &#123; * if (ExampleApi == null) &#123; * Retrofit retrofit = new Retrofit.Builder() * .client(new OkHttpClient()) * .baseUrl(UrlConstants.HOST) * .addConverterFactory(GsonConverterFactory.create()) * .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) * .build(); * ExampleApi = retrofit.create(ExampleApi.class); * &#125; * return ExampleApi; * &#125; */ return NetWork.getExampleApi().register(sendBean); &#125; @Override public Observable&lt;BaseResponseData&lt;String&gt;&gt; unregister(UnRegisterBean sendBean) &#123; return null; &#125;&#125; 1234567891011121314151617181920212223public class LocalExampleDataSource implements ExampleApi &#123; @Nullable private static LocalExampleDataSource INSTANCE; public static LocalExampleDataSource getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new LocalExampleDataSource(); &#125; return INSTANCE; &#125; @Override public Observable&lt;BaseResponseData&lt;String&gt;&gt; register(@Body RegisterBean sendBean) &#123; return null; &#125; @Override public Observable&lt;BaseResponseData&lt;String&gt;&gt; unregister(UnRegisterBean sendBean) &#123; ...... return Observable.just(baseResponseData); &#125;&#125; 致谢","tags":[{"name":"Android","slug":"Android","permalink":"http://lianghuiyong.online/tags/Android/"}]},{"title":"使用Charles抓Https包过程","date":"2017-04-03T10:59:53.000Z","path":"2017/04/03/使用Charles抓Https包过程/","text":"1、平台Windows 10 Charles 4.0.2 2、代理端口监听 3、SSL证书设置 4、SSL端口设置手机获取SSL认证：http://charlesproxy.com/getssl","tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://lianghuiyong.online/tags/服务器开发/"}]},{"title":"Android studio 2.3 Cmake Jni 环境搭建","date":"2017-03-31T11:18:19.000Z","path":"2017/03/31/Android-studio-2-3-Cmake-Jni-环境搭建/","text":"使用体验c++的支持很优雅！ 环境需求1、Android studio 2.3 2、NDK 版本：14.1.38 3、Cmake(SDK tools 列表里下载) gradle配置12345678910111213141516171819202122232425262728android &#123; ...... defaultConfig &#123; ...... externalNativeBuild &#123; cmake &#123; //以下为C开发方式 //cppFlags \"\" //以下为C++开发方式，具体参数可以百度下 cppFlags \"-std=c++11\", \"-frtti\", \"-fexceptions\" &#125; ndk &#123; //生成的平台支持列表 abiFilters 'armeabi-v7a' &#125; &#125; &#125; ...... externalNativeBuild &#123; cmake &#123; //Cmake 配置文件 path \"CMakeLists.txt\" &#125; &#125;&#125; CMakeLists示例说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//版本相关cmake_minimum_required(VERSION 3.6)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds it for you.# Gradle automatically packages shared libraries with your APK.//配置c++文件路径和头文件路径set(CMAKE_VERBOSE_MAKEFILE on)set(libs \"$&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs\")include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/include)#--------------------------------------------------- import ---------------------------------------------------#//根据项目自己的Jni依赖需求,需要引用第三方so库的时候，使用add_libraryadd_library(libopencv_java3 SHARED IMPORTED )set_target_properties(libopencv_java3 PROPERTIES IMPORTED_LOCATION \"$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_java3.so\")//这个在gradle里配置了，这里应该是不用写的set(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -std=gnu++11 -fexceptions -frtti\")//自己的so库lib名，以及依赖的c++文件add_library( # Sets the name of the library. scanner # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). # Associated headers in the same location as their source # file are automatically included. src/main/cpp/libmanager.cpp src/main/cpp/scanner.cpp)find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log)//库连接，scanner依赖了后面的静态库target_link_libraries(scanner android log libopencv_java3 $&#123;log-lib&#125; )","tags":[{"name":"Android","slug":"Android","permalink":"http://lianghuiyong.online/tags/Android/"}]},{"title":"echo 服务器开发笔记","date":"2017-03-31T01:36:24.000Z","path":"2017/03/31/echo-服务器开发笔记/","text":"1、解决Http x509 未认证的验证问题123456func newClient() *http.Client &#123; tr := &amp;http.Transport&#123; TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: true&#125;, &#125; return &amp;http.Client&#123;Transport: tr&#125;&#125;","tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://lianghuiyong.online/tags/服务器开发/"}]},{"title":"Android Apk反编译","date":"2017-03-30T03:20:06.000Z","path":"2017/03/30/Android-Apk反编译/","text":"1、解apk包apktool d -s ***.apk 2、反编译class文件dex2jar.bat D:\\apktool\\d2japk\\classes.dex","tags":[{"name":"Android","slug":"Android","permalink":"http://lianghuiyong.online/tags/Android/"}]},{"title":"echo框架使用：获取与配置","date":"2017-03-12T09:12:02.000Z","path":"2017/03/12/echo框架使用：获取与配置/","text":"运行环境 1Linux :CentOS 7.0 Go :go version go1.8 linux/amd64 GOPATH :/root/sdk/go/lib 运行环境 2Windows10 Go :go version go1.8 windows/amd64 GOPATH :C:\\Go\\lib 安装 gityum install git 获取 echogo get -v -u github.com/labstack/echo/ 获取日志 对于下载失败的库，都可以到github.com/golang/去找！ 123456789github.com/labstack/echo (download)github.com/labstack/gommon (download)github.com/mattn/go-colorable (download)github.com/mattn/go-isatty (download)github.com/valyala/fasttemplate (download)Fetching https://golang.org/x/crypto/acme/autocert?go-get=1https fetch failed: Get https://golang.org/x/crypto/acme/autocert?go-get=1: dial tcp 216.239.37.1:443: i/o timeoutpackage golang.org/x/crypto/acme/autocert: unrecognized import path \"golang.org/x/crypto/acme/autocert\" (https fetch: Get https://golang.org/x/crypto/acme/autocert?go-get=1: dial tcp 216.239.37.1:443: i/o timeout) 1、下到一半的时候可能会出现错误，这时，编译项目的时候缺少哪个包就去对应的下就好了，guthub上也有一些相对应的包（github源的包都能go get到的） go get -u -v github.com/stretchr/testify/assert 2、项目会出现”golang.org/x/net/context”丢失，使用间接获取， go get -u -v github.com/golang/net 在golang.org文件夹下创建x文件夹，将$GOPATH\\src\\github.com\\golang 下的net复制到$GOPATH\\src\\golang.org\\x目录下 ,然后执行： go install -v golang.org/x/net/context 3、运行时可能会出现找不到包cannot find package “github.com/dgrijalva/jwt-go” go get -u -v github.com/dgrijalva/jwt-go 再安装一遍echogo install -v github.com/labstack/echo/ echo测试代码 api.go12345678910111213141516171819202122package apiimport ( \"../data\" \"github.com/labstack/echo\" \"net/http\")//noinspection GoUnusedExportedFunctionfunc PostTest(c echo.Context) error&#123; movies := []data.Movie&#123; &#123;\"金刚狼\", \"2017\", []string&#123;\"休·杰克曼\", \"达芙妮·基恩\", \"帕特里克·斯图尔特\"&#125;&#125;, &#123;\"极限特工\", \"2017\", []string&#123;\"范·迪塞尔\", \"露比·罗丝\", \"妮娜·杜波夫\"&#125;&#125;, &#123;\"功夫瑜伽\", \"2017\", []string&#123;\"成龙\", \"李治廷\", \"张艺兴\"&#125;&#125;, &#123;\"生化危机：终章\", \"2017\", []string&#123;\"米拉·乔沃维奇\", \"伊恩·格雷\", \"艾丽·拉特\"&#125;&#125;, &#125; baseMovie := data.BaseResponse&#123;http.StatusOK, \"success\", movies&#125; return c.JSONPretty(http.StatusOK, baseMovie,\" \")&#125; BaseResponse.go123456789101112package data//Go 默认是不支持泛型的，定义一个接口结构体，即可当泛型使用type T interface &#123;&#125;type BaseResponse struct &#123; Code int Msg string Data T&#125; Movie.go1234567package datatype Movie struct &#123; Title string Year string Actors []string&#125; main.go12345678910111213141516171819202122232425262728293031323334package mainimport ( \"github.com/labstack/echo\" \"github.com/labstack/echo/middleware\" \"./api\")func main() &#123; e := echo.New() // Middleware e.Use(middleware.Logger()) e.Use(middleware.Recover()) //CORS e.Use(middleware.CORSWithConfig(middleware.CORSConfig&#123; AllowOrigins: []string&#123;\"*\"&#125;, AllowMethods: []string&#123;echo.GET, echo.HEAD, echo.PUT, echo.PATCH, echo.POST, echo.DELETE&#125;, &#125;)) //static file serviing e.Static(\"/static\", \"assets\") // Routers e.POST(\"/\", api.PostTest) //e.GET(\"/users/:id\", controllers.ShowUser) //e.GET(\"/users\", controllers.AllUsers) //e.PUT(\"/users/:id\", controllers.UpdateUser) //e.DELETE(\"/users/:id\",controllers.DeleteUser) // Server e.Start(\":1323\")&#125; echo监控123\"D:\\Program Files (x86)\\JetBrains\\Gogland\\bin\\runnerw.exe\" C:/Go\\bin\\go.exe run E:/Code/Go-Home/server/main.go⇛ http server started on [::]:1323&#123;\"time\":\"2017-03-13T20:05:50.8909566+08:00\",\"id\":\"\",\"remote_ip\":\"::1\",\"host\":\"localhost:1323\",\"method\":\"POST\",\"uri\":\"/\",\"status\":200, \"latency\":0,\"latency_human\":\"0s\",\"bytes_in\":0,\"bytes_out\":973&#125; 请求测试 CentOS 7 防火墙问题1.测试是否可以访问telnet 123.56.4.89 1323 2.CentOS 7 关闭防火墙firewall-cmd --zone=public --add-port=55555/tcp --permanent firewall-cmd --reload 命令含义： –zone #作用域 –add-port=80/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效","tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://lianghuiyong.online/tags/服务器开发/"}]},{"title":"GO基础：复合数据类型","date":"2017-03-12T08:14:43.000Z","path":"2017/03/12/GO基础：复合数据类型/","text":"运行环境：go version go1.8 windows/amd64 编辑器JetBrains Gogland Go 官方test代码$GOPATH$\\test 练习代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package mainimport ( \"fmt\" \"encoding/json\" \"log\")func main() &#123; fmt.Println(\"--------------数组测试---------------\") test_array() fmt.Println(\"--------------切片测试---------------\") test_slice() fmt.Println(\"--------------map测试---------------\") test_map() fmt.Println(\"--------------json测试---------------\") test_json()&#125;/*-----测试数组-----*/func test_array() &#123; arr := []int&#123;1, 2, 3, 4&#125; fmt.Println(arr) arr[0] = 3 arr[1] = 3 arr[2] = 3 arr[3] = 3 fmt.Println(arr)&#125;/*------测试切片-----*/func test_slice() &#123; mouth := []string&#123;1: \"一月\", 2: \"二月\", 3: \"三月\", 4: \"四月\", 5: \"五月\", 6: \"六月\", 7: \"七月\", 8: \"八月\", 9: \"九月\", 10: \"十月\", 11: \"十一月\", 12: \"十二月\"&#125; slice1 := mouth[1:3] slice2 := mouth[2:5] fmt.Println(slice1) fmt.Println(slice2) fmt.Println(mouth) reverse(mouth[:]) fmt.Println(mouth) fmt.Println(slice1) fmt.Println(slice2)&#125;/*--------数组反转--------*/func reverse(s []string) &#123; for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125;&#125;func test_map() &#123; //创建map1 map1 := map[int]string&#123;&#125; //初始化赋值 map1[1] = \"hello1\" map1[2] = \"world2\" map1[3] = \"world3\" map1[4] = \"world4\" map1[5] = \"world5\" map1[6] = \"world6\" map1[7] = \"world7\" map1[8] = \"world8\" map1[9] = \"world9\" map1[10] = \"!!!!!!10\" //取值 fmt.Println(map1) fmt.Println(map1[1]) // Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。 // 在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的， // 每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。 //for _, value := range map1 &#123; // println(\"\\t\", value, \"\\n\") //&#125; //删除 delete(map1, 2) fmt.Println(map1) fmt.Println(map1[4] + \"1\")&#125;//使用 json解析的结构体成员变量首字母必须大写！！！func test_json() &#123; //Go 默认是不支持泛型的，定义一个接口结构体，即可当泛型使用 type T interface &#123; &#125; type Movie struct &#123; Title string Year string Actors []string &#125; type BaseResponse struct &#123; Code int Msg string Data T &#125; movies := []Movie&#123; &#123;\"金刚狼\", \"2017\", []string&#123;\"休·杰克曼\", \"达芙妮·基恩\", \"帕特里克·斯图尔特\"&#125;&#125;, &#123;\"极限特工\", \"2017\", []string&#123;\"范·迪塞尔\", \"露比·罗丝\", \"妮娜·杜波夫\"&#125;&#125;, &#123;\"功夫瑜伽\", \"2017\", []string&#123;\"成龙\", \"李治廷\", \"张艺兴\"&#125;&#125;, &#123;\"生化危机：终章\", \"2017\", []string&#123;\"米拉·乔沃维奇\", \"伊恩·格雷\", \"艾丽·拉特\"&#125;&#125;, &#125; baseMovie := BaseResponse&#123;200, \"success\", movies&#125; //一个是不带缩进显示的，一个是带缩进显示的 //data, err := json.Marshal(baseMovie) data, err := json.MarshalIndent(baseMovie, \"\", \" \") if err != nil &#123; log.Fatalf(\"JSON marshaling failed: %s\", err) &#125; fmt.Printf(string(data))&#125; 输出部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758--------------数组测试---------------[1 2 3 4][3 3 3 3]--------------切片测试---------------[一月 二月][二月 三月 四月][ 一月 二月 三月 四月 五月 六月 七月 八月 九月 十月 十一月 十二月][十二月 十一月 十月 九月 八月 七月 六月 五月 四月 三月 二月 一月 ][十一月 十月][十月 九月 八月]--------------map测试---------------map[3:world3 5:world5 6:world6 7:world7 9:world9 2:world2 4:world4 8:world8 10:!!!!!!10 1:hello1]hello1map[10:!!!!!!10 1:hello1 4:world4 8:world8 6:world6 7:world7 9:world9 3:world3 5:world5]world41--------------json测试---------------&#123; \"Code\": 200, \"Msg\": \"success\", \"Data\": [ &#123; \"Title\": \"金刚狼\", \"Year\": \"2017\", \"Actors\": [ \"休·杰克曼\", \"达芙妮·基恩\", \"帕特里克·斯图尔特\" ] &#125;, &#123; \"Title\": \"极限特工\", \"Year\": \"2017\", \"Actors\": [ \"范·迪塞尔\", \"露比·罗丝\", \"妮娜·杜波夫\" ] &#125;, &#123; \"Title\": \"功夫瑜伽\", \"Year\": \"2017\", \"Actors\": [ \"成龙\", \"李治廷\", \"张艺兴\" ] &#125;, &#123; \"Title\": \"生化危机：终章\", \"Year\": \"2017\", \"Actors\": [ \"米拉·乔沃维奇\", \"伊恩·格雷\", \"艾丽·拉特\" ] &#125; ]&#125; 在此感谢博客被百度、谷歌收录","tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://lianghuiyong.online/tags/服务器开发/"}]},{"title":"Go基础：循环语句","date":"2017-03-05T15:02:16.000Z","path":"2017/03/05/Go基础：循环语句/","text":"运行环境：go version go1.8 windows/amd64 编辑器JetBrains Gogland Go 官方test代码$GOPATH$\\test 练习代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package mainimport \"fmt\"func main() &#123; fmt.Println(\"--------------------test_for--------------------\") test_for() fmt.Println(\"--------------------test_if--------------------\") test_if() fmt.Println(\"--------------------test_switch--------------------\") test_switch() fmt.Println(\"--------------------test_defer--------------------\") test_defer()&#125;func test_for() &#123; sum := 0 for i := 0; i &lt; 10; i ++ &#123; sum += i &#125; fmt.Println(\"sum:\", sum) // sum: 45&#125;func test_if() &#123; //表达式无需小括号 if true &#123; fmt.Println(\"is test if\") &#125; else &#123; fmt.Println(\"is test if\") &#125; //表达式可执行一部分简单的语句（赋值、函数等） if one := 1; true &#123; fmt.Println(\"is test if \", one, \" teue\") &#125; else &#123; fmt.Println(\"is test if\") &#125; //简单的调用 if test_for(); false &#123; fmt.Println(\"is test if \", \"test_for\") &#125; else &#123; fmt.Println(\"is test if\") &#125;&#125;func test_switch() &#123; //同样可执行简单语句，而且case可为bool值！ switch i5 := 5; true &#123; case i5 &gt; 5: fmt.Println(\"i5 &gt; 5\") case i5 == 5: fmt.Println(\"i5 == 5\") case i5 &lt; 5: fmt.Println(\"i5 &lt; 5\") &#125; i5 := 5 switch i5 &#123; case 0: fmt.Println(\"i5 is 0\") case 1: fmt.Println(\"i5 is 1\") case 2: fmt.Println(\"i5 is 2\") case 3: fmt.Println(\"i5 is 3\") case 4: fmt.Println(\"i5 is 4\") case 5: fmt.Println(\"i5 is 5\") &#125;&#125;//defer会将函数进行入栈，当包含defer的函数返回时，被入栈的函数将一一出栈。func test_defer() &#123; test_defer_hello() fmt.Println(\"counting\") for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(\"done\")&#125;func test_defer_hello() &#123; defer fmt.Println(\"world\") fmt.Println(\"hello\")&#125; 输出部分12345678910111213141516171819202122232425--------------------test_for--------------------sum: 45--------------------test_if--------------------is test ifis test if 1 teuesum: 45is test if--------------------test_switch--------------------i5 == 5i5 is 5--------------------test_defer--------------------helloworldcountingdone9876543210","tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://lianghuiyong.online/tags/服务器开发/"}]},{"title":"Go基础：类型、变量、函数","date":"2017-03-05T13:57:34.000Z","path":"2017/03/05/Go基础：类型、变量、函数/","text":"运行环境：go version go1.8 windows/amd64 编辑器JetBrains Gogland Go 官方test代码$GOPATH$\\test 基本类型12345678boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名, 代表一个Unicode码float32 float64complex64 complex128 练习代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/*包名*/package main/*导包*/import ( \"fmt\")func main() &#123; fmt.Println(\"Go : Hello World!\") fmt.Println(add(25, 25)) fmt.Println(swap(\"huiyong\", \"liang\")) fmt.Println(split(25))&#125;//1、参数类型相同(x int, y int)，可简写成(x, y int)//2、返回类型为 intfunc add(x, y int) int &#123; return x + y&#125;//1、返回类型为 (string, string)，func swap(x, y string) (string, string) &#123; return y, x&#125;//1、返回类型(x, y int)，已经声明了返回变量x，y//2、指定了返回变量时，return x, y 可简写成 return、//3、 `:=` 简洁赋值语句用在明确类型的地方，用于替代 `var`//等同//func split(sum int) (int, int) &#123;// x := sum * 4 / 9// y := sum - x// return x, y//&#125;func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return&#125;","tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://lianghuiyong.online/tags/服务器开发/"}]},{"title":"Go环境搭建","date":"2017-03-01T13:51:01.000Z","path":"2017/03/01/Go环境搭建/","text":"1、将go sdk解压到 /root/sdk文件夹1# tar -xzf go1.7.linux-amd64.tar.gz -C /root/sdk 2、.bashrc 添加path123export GOROOT=/root/sdk/goexport GOPATH=$GOROOT/libexport PATH=$PATH:$GOROOT/bin 3、使path生效1# source .bashrc 4、go env 查看信息","tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://lianghuiyong.online/tags/服务器开发/"}]},{"title":"自定义按钮ShapeButton","date":"2017-02-28T11:34:35.000Z","path":"2017/02/28/自定义按钮ShapeButton/","text":"开发时，为了一个简单的按钮要写一堆的样式代码，我表示我在写假代码。 地址Github 地址 可定制属性123456app:stroke :细线宽度app:radius :拐角宽度app:normalColor :按钮颜色app:pressColor :按钮选中颜色app:stroke_normalColor :细线颜色app:stroke_pressColor :细线选中后的颜色 示例图代码12345678910&lt;com.better.customui.widget.ShapeButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"123456\" android:textColor=\"#FF44FF\" app:pressColor=\"#2F000000\" app:radius=\"3dip\" app:stroke=\"0.5dip\" app:stroke_normalColor=\"#553355\" app:stroke_pressColor=\"#8F553355\" /&gt; 12345678&lt;com.better.customui.widget.ShapeButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"123456\" android:textColor=\"#FF44FF\" app:normalColor=\"#FF3988D2\" app:pressColor=\"#9F3988D2\" app:radius=\"3dp\" /&gt;","tags":[{"name":"Android 自定义UI","slug":"Android-自定义UI","permalink":"http://lianghuiyong.online/tags/Android-自定义UI/"}]},{"title":"通过系统通讯录获取联系人号码","date":"2017-02-28T11:26:27.000Z","path":"2017/02/28/通过系统通讯录获取联系人号码/","text":"1、点击跳转到通讯录界面123Uri uri = Uri.parse(\"content://contacts/people\");Intent intent = new Intent(Intent.ACTION_PICK, uri);startActivityForResult(intent, 0); 2、获取通讯录姓名和手机号码12345678910111213141516171819202122232425262728293031323334353637@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case 0: if (data == null) &#123; return; &#125; //处理返回的data,获取选择的联系人信息 Uri uri = data.getData(); String[] contacts = getPhoneContacts(uri); photoNo.setText(contacts[1]); break; &#125;&#125;private String[] getPhoneContacts(Uri uri) &#123; String[] contact = new String[2]; //得到ContentResolver对象 ContentResolver cr = getContentResolver(); //取得电话本中开始一项的光标 Cursor cursor = cr.query(uri, null, null, null, null); if (cursor != null) &#123; cursor.moveToFirst(); //取得联系人姓名 int nameFieldColumnIndex = cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME); contact[0] = cursor.getString(nameFieldColumnIndex); //取得电话号码 String ContactId = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID)); Cursor phone = cr.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID + \"=\" + ContactId, null, null); if (phone != null) &#123; phone.moveToFirst(); contact[1] = phone.getString(phone.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); &#125; phone.close(); cursor.close(); &#125; else &#123; return null; &#125; return contact;&#125; 3、权限12&lt;uses-permission android:name=\"android.permission.READ_CONTACTS\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://lianghuiyong.online/tags/Android/"}]},{"title":"GitHub使用Hexo搭建博客与版本控制","date":"2017-02-20T15:16:30.205Z","path":"2017/02/20/Github使用hexo搭建博客与版本控制/","text":"一. 本地准备工作1、安装Node.js、Git 二. 创建github仓库（以以下规则为准）1、仓库名：github名.github.io（lianghuiyong.github.io） 2、创建时勾选Initialize this repository with a README，会自动创建master分支 3、创建仓库分支hexo 1) 本地新建一个文件夹test 2) test文件夹里鼠标右键选择Git bash，输入以下指令： 123456git initgit remote add origin https://github.com/github名/github名.github.io.gitgit pull origin mastergit branch hexogit checkout hexogit push origin hexo git常用命令12分支master（展示网页的分支必须是master），用于放hexo生成的静态网站文件。分支hexo（这个可以随意取），用于存储hexo文件。 三. 第一次初始化hexo项目（不是从自己的github仓库下载过来的hexo工程文件）注：本地电脑要与github通过验证，git提交协议有ssh，HTTPS等验证方式，我用的HTTPS。 在自己创建的博客目录里鼠标右键选择Git bash，输入以下指令：1、获取hexo工程目录1npm install -g hexo-cli 2、初始化hexo，现在我感觉就是初始化hexo工程根目录下的_config.yml：1hexo init 3、下载主题，默认的没用过，我用的yilia1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 4、配置主题，打开hexo根目录下的_config.yml：theme: yilia （注意：后有个空格） 5、在上面打开的_config.yml文件，配置hexo生成的静态网页提交仓库地址（注意空格）1234deploy: type: git repo: https://github.com/github名/github名.github.io.git branch: master 6、生成gitahub静态博客123hexo cleanhexo ghexo d 7、在浏览器上打开 http://github名.github.io.git ，看看有没有效果 四. 项目目录搭建好后，将hexo工程目录提交到github的hexo分支1、将hexo工程下的.deploy_git删除 2、进themes/yilia把 .git隐藏目录删除 3、进到hexo工程根目录，初始化git1git init 4、添加github仓库地址1git remote add origin https://github.com/github名/github名.github.io.git 5、获取github的hexo分支1git pull origin hexo 6、本地切换到hexo分支1git checkout hexo 7、添加hexo工程目录到git新节点12git add .git commit -m \"updata hexo\" 8、提交新节点到github仓库1git push origin hexo 五. 初始化项目目录后或者从github的hexo分支获取到hexo工程目录附：从hithub获取hexo目录 123451）、创建一个博客文件夹，进去并初始化 git init git remote add origin https://github.com/github名/github名.github.io.git2）、获取hexo分支目录 git pull origin hexo 1、写静态博客123hexo new “***”hexo ghexo d 拓展使用Android Studio等编译器来版本控制博客项目文件 git config core.longpaths true","tags":[{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"http://lianghuiyong.online/tags/GitHub-Pages/"},{"name":"Hexo","slug":"Hexo","permalink":"http://lianghuiyong.online/tags/Hexo/"},{"name":"版本管理","slug":"版本管理","permalink":"http://lianghuiyong.online/tags/版本管理/"}]},{"title":"打包出现： Cannot merge new index 65725 into a non-jumbo instruction!","date":"2017-02-20T02:46:37.000Z","path":"2017/02/20/打包出现：-Cannot-merge-new-index-65725-into-a-non-jumbo-instruction/","text":"1、build.gradle里添加12345android &#123; dexOptions &#123; jumboMode true &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://lianghuiyong.online/tags/Android/"}]},{"title":"Android JCenter仓库搭建","date":"2016-12-21T08:22:23.000Z","path":"2016/12/21/Android-JCenter仓库搭建/","text":"JCenter准备 用GitHub账号登陆bintray。 新建仓库，Add New Repository 库工程 创建AS项目 工程内创建Module(Android Librarys)以下修改都是在Module内修改的 build.gradle 1234567891011121314151617181920212223242526272829303132333435363738394041apply plugin: 'com.android.library'buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.3' classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5' &#125;&#125;android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.0\" defaultConfig &#123; minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName \"0.0.3\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:25.0.1'&#125;apply from: \"bintrayUpload.gradle\" Module根文件夹下新建bintrayUpload.gradle，拷贝以下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138apply plugin: 'com.github.dcendents.android-maven'apply plugin: 'com.jfrog.bintray'//加载属性文件Properties properties = new Properties()File localPropertiesFile = project.file(\"bintray.properties\");if (localPropertiesFile.exists()) &#123; properties.load(localPropertiesFile.newDataInputStream())&#125;File projectPropertiesFile = project.file(\"project.properties\");if (projectPropertiesFile.exists()) &#123; properties.load(projectPropertiesFile.newDataInputStream())&#125;//读取属性def projectRepositoryName = properties.getProperty(\"project.repositoryName\")def projectName = properties.getProperty(\"project.name\")def projectGroupId = properties.getProperty(\"project.groupId\")def projectArtifactId = properties.getProperty(\"project.artifactId\")def projectVersionName = android.defaultConfig.versionNamedef projectPackaging = properties.getProperty(\"project.packaging\")def projectSiteUrl = properties.getProperty(\"project.siteUrl\")def projectGitUrl = properties.getProperty(\"project.gitUrl\")def developerId = properties.getProperty(\"developer.id\")def developerName = properties.getProperty(\"developer.name\")def developerEmail = properties.getProperty(\"developer.email\")def bintrayUser = properties.getProperty(\"bintray.user\")def bintrayApikey = properties.getProperty(\"bintray.apiKey\")def bintrayOrganizationId = properties.getProperty(\"bintray.organizationId\");def javadocName = properties.getProperty(\"javadoc.name\")/**这句代码一定要加否则会出现如下错误* Could not upload to 'https://api.bintray.com/content/coolcode/maven/LibUiBase/1.0.0/CommonLibrary/LibUiBase/1.0.0/LibUiBase-1.0.0.pom': HTTP/1.1 400 Bad Request [message:Unable to upload files: Maven group, artifact or version defined in the pom file do not match the file path 'CommonLibrary/LibUiBase/1.0.0/LibUiBase-1.0.0.pom']* */group = projectGroupId// 配置生成POM.xml文件的参数install &#123; repositories.mavenInstaller &#123; pom &#123; project &#123; name projectName groupId projectGroupId artifactId projectArtifactId version projectVersionName packaging projectPackaging url projectSiteUrl licenses &#123; license &#123; name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' &#125; &#125; developers &#123; developer &#123; id developerId name developerName email developerEmail &#125; &#125; scm &#123; connection projectGitUrl developerConnection projectGitUrl url projectSiteUrl &#125; &#125; &#125; &#125;&#125;tasks.withType(Javadoc) &#123; options.addStringOption('Xdoclint:none', '-quiet') options.addStringOption('encoding', 'UTF-8') options.addStringOption('charSet', 'UTF-8')&#125;//生成sources.jartask sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = 'sources'&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;//生成javadoc.jartask javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;//javadoc的配置javadoc &#123; options &#123; encoding \"UTF-8\" charSet 'UTF-8' author true version projectVersionName links \"http://docs.oracle.com/javase/7/docs/api\" title javadocName &#125;&#125;/**userOrg为bintray账号信息里面的Organization Id*repo为你创建的仓库名称* 如果上述两个字段写错了，则会出现下面类似的错误*Could not create package 'huangxuanheng/maven/fragmentstack': HTTP/1.1 404 Not Found [message:Repo 'maven' was not found]*** */bintray &#123; user = bintrayUser key = bintrayApikey configurations = ['archives'] pkg &#123; userOrg = bintrayOrganizationId repo = projectRepositoryName name = projectName websiteUrl = projectSiteUrl vcsUrl = projectGitUrl licenses = [\"Apache-2.0\"] publish = true &#125;&#125; 在Module根目录下，新建project.properties文件，添加以下内容，并自行修改对应参数 1234567891011121314151617#project#仓库名称，就是在bintray官网建立的仓库的名称project.repositoryName=仓库名称#bintray仓库里显示的项目名称project.name=name#项目组id，这个取的时候别跟别人的相冲突就行project.groupId=com.***.***#项目id,一般同project.nameproject.artifactId=name#打包类型project.packaging=aar#项目官方网站地址project.siteUrl=https://github.com/lianghuiyong/CustomUI#项目git地址project.gitUrl=https://github.com/lianghuiyong/CustomUI#生成的javadoc名称javadoc.name=CustomUI.Doc 在Module根目录下，新建bintray.properties文件，添加对应参数 12345678910111213141516#配置bintray账号相关信息#bintray用户名,不是登陆邮箱,是个人中心右上角显示的名字bintray.user=user#bintray的ApiKeybintray.apiKey=apiKey#bintray的Organization Idbintray.organizationId=organizationId#配置开发者信息#昵称developer.id=lianghuiyong#姓名developer.name=lianghuiyong#邮箱developer.email=lianghuiyong@outlook.com 提交 gradlew install gradlew bintrayUpload 将库添加到公共库进bintray，打开仓库对应的项目 add to JCenter send","tags":[{"name":"Android","slug":"Android","permalink":"http://lianghuiyong.online/tags/Android/"},{"name":"JCenter","slug":"JCenter","permalink":"http://lianghuiyong.online/tags/JCenter/"}]},{"title":"5.0侧栏顶部透明，仿网易云音乐效果。","date":"2016-12-16T02:19:52.000Z","path":"2016/12/16/5-0侧栏顶部透明，仿网易云音乐效果。/","text":"一. 主题1、基本主题123456&lt;style name=\"Base.AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!--text style--&gt; &lt;item name=\"android:textColor\"&gt;@color/textColor&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"android:windowAnimationStyle\"&gt;@style/AnimationActivity&lt;/item&gt;&lt;/style&gt; 2、5.0以上系统适配主题和5.0以下的主题12345&lt;!--标题栏透明--&gt;&lt;style name=\"Base.TransParent\" parent=\"Base.AppTheme\"&gt; &lt;item name=\"android:windowDrawsSystemBarBackgrounds\"&gt;true&lt;/item&gt; &lt;item name=\"android:statusBarColor\"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 123&lt;!--标题栏透明--&gt;&lt;style name=\"Base.TransParent\" parent=\"Base.AppTheme\"&gt;&lt;/style&gt; 3、页面 1234&lt;style name=\"TransParentTheme\" parent=\"Base.TransParent\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/mainColorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/mainColorPrimaryDark&lt;/item&gt;&lt;/style&gt; 二. 页面使用1234567891011121314&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--其他布局--&gt; &lt;......&gt; &lt;!--侧栏引用布局--&gt; &lt;include layout=\"@layout/nav_header_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://lianghuiyong.online/tags/Android/"}]},{"title":"CentOS7 网络设置","date":"2016-11-05T09:39:12.000Z","path":"2016/11/05/CentOS7 网络设置/","text":"1、使用虚拟机安装CentOS，并使用桥接方式链接网络2、编辑网络配置12cd /etc/sysconfig/network-scripts/vi ifcfg-eno16777736 更改12BOOTPROTO=DHCP -&gt; BOOTPROTO=staticONBOOT=no -&gt; ONBOOT=yes 增加 123456HWADDR=aa:bb:cc:dd:ee;ff //虚拟机的mac地址,在虚拟机的设置-网络中可以查看GATEWAY=192.168.0.1 //网关，需要和主机一致IPADDR=192.168.0.222 //虚拟机的ip,保持和主机一个网段NETMASK=255.255.255.0 //子网掩码DNS1=8.8.8.8 //DNSDNS2=114.114.114.114 //DNS 1、重启网络服务：service network restart2、试下：ping www.baidu.com 3、安装网络工具1yum install net-tools 4、安装SSH1yum install openssh-server -y 5、结语12本以为后面会以后端开发继续往前写的，后面发现其实自己工作重心和目前对自己开发有利的方向还是前端，恰巧这几天微信小程序可以开发，转而学习微信小程序了。后端是另一个开始，话说我也是Go的追逐者。","tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://lianghuiyong.online/tags/服务器开发/"}]},{"title":"Git使用笔录","date":"2016-10-29T05:09:43.000Z","path":"2016/10/29/Git使用笔录/","text":"git工具下载：https://git-scm.com/download/配置git信息 12git config --global user.name \"Your name\"git config --global user.email \"Your email\" 1、git本地仓库初始化1234git initgit remote remove/add origin git仓库地址git pull origin master master //取远程主分支git pull origin Liang Liang //取远程Liang的分支 2、提交远程到仓库123git add .git commot -m \"提交信息\"git push origin MoLiang //提交到远程分支MoLiang 3、分支管理12git branch Liang //创建Liang的分支git branch origin/Liang //创建Liang的远程分支 4、合并主分区123git checkout master (主分支)git merge origin/MoLianggit push origin master:master //$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 5、回滚主分支1234$ git log 查看commit的sha1值+$ git reset 3a48e096339f5c840a8d15435ff88cbd11ccd31f$ git stash$ git push -f origin master","tags":[{"name":"版本管理","slug":"版本管理","permalink":"http://lianghuiyong.online/tags/版本管理/"},{"name":"Git","slug":"Git","permalink":"http://lianghuiyong.online/tags/Git/"}]}]